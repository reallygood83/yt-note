import { NextRequest, NextResponse } from 'next/server';

// Enhanced YouTube transcript extractor with better error handling
export async function POST(request: NextRequest) {
  try {
    const { videoId } = await request.json();
    
    if (!videoId) {
      return NextResponse.json({ error: '비디오 ID가 필요합니다.' }, { status: 400 });
    }

    console.log('[Enhanced YouTube API] 자막 추출 시작:', videoId);

    // Step 1: Fetch the YouTube watch page with enhanced headers
    const watchPageResponse = await fetch(`https://www.youtube.com/watch?v=${videoId}`, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
        'Accept-Language': 'ko-KR,ko;q=0.9,en;q=0.8',
        'Accept-Encoding': 'gzip, deflate, br',
        'DNT': '1',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Sec-Fetch-User': '?1',
        'Cache-Control': 'max-age=0'
      }
    });

    if (!watchPageResponse.ok) {
      console.error('[Enhanced YouTube API] Watch page fetch failed:', watchPageResponse.status);
      return NextResponse.json({ 
        error: 'YouTube 페이지를 불러올 수 없습니다.',
        status: watchPageResponse.status 
      }, { status: 404 });
    }

    const html = await watchPageResponse.text();
    console.log('[Enhanced YouTube API] HTML 페이지 길이:', html.length);

    // Step 2: Extract video metadata for fallback
    const titleMatch = html.match(/<title[^>]*>([^<]*)<\/title>/);
    const descMatch = html.match(/"shortDescription":"([^"]*)/);
    const videoTitle = titleMatch ? titleMatch[1].replace(' - YouTube', '') : '';
    const videoDesc = descMatch ? descMatch[1].substring(0, 500) : '';

    // Step 3: Try multiple methods to find caption data
    let captionTracks = null;
    let captionMethod = '';

    // Method 1: ytInitialPlayerResponse
    const ytPlayerMatch = html.match(/var ytInitialPlayerResponse = ({.*?});/s);
    if (ytPlayerMatch) {
      try {
        const playerData = JSON.parse(ytPlayerMatch[1]);
        captionTracks = playerData?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
        if (captionTracks && captionTracks.length > 0) {
          captionMethod = 'ytInitialPlayerResponse';
          console.log('[Enhanced YouTube API] 방법 1 성공: ytInitialPlayerResponse에서 자막 발견');
        }
      } catch (e) {
        console.log('[Enhanced YouTube API] 방법 1 실패: ytInitialPlayerResponse 파싱 오류');
      }
    }

    // Method 2: Fallback to captionTracks regex if Method 1 failed
    if (!captionTracks) {
      const captionMatch = html.match(/"captionTracks":\s*(\[.*?\])/);
      if (captionMatch) {
        try {
          captionTracks = JSON.parse(captionMatch[1]);
          captionMethod = 'regex';
          console.log('[Enhanced YouTube API] 방법 2 성공: regex로 자막 발견');
        } catch (e) {
          console.log('[Enhanced YouTube API] 방법 2 실패: captionTracks 파싱 오류');
        }
      }
    }

    // Step 4: Handle case where no captions are found
    if (!captionTracks || captionTracks.length === 0) {
      console.warn('[Enhanced YouTube API] 자막을 찾을 수 없음');
      return NextResponse.json({
        transcripts: [],
        fallbackData: {
          title: videoTitle,
          description: videoDesc
        },
        message: '이 영상에는 자막이 없습니다. 메타데이터를 기반으로 노트를 생성합니다.',
        method: 'fallback'
      });
    }

    console.log(`[Enhanced YouTube API] ${captionMethod} 방법으로 ${captionTracks.length}개 자막 트랙 발견`);

    // Step 5: Select the best caption track
    const koreanTrack = captionTracks.find((track: any) => 
      track.languageCode === 'ko' || track.languageCode === 'ko-KR'
    );
    const autoTrack = captionTracks.find((track: any) => 
      track.vssId?.includes('.asr') || track.kind === 'asr'
    );
    const selectedTrack = koreanTrack || autoTrack || captionTracks[0];

    console.log('[Enhanced YouTube API] 선택된 자막:', {
      language: selectedTrack.languageCode,
      name: selectedTrack.name?.simpleText || selectedTrack.name,
      isAutoGenerated: selectedTrack.vssId?.includes('.asr') || selectedTrack.kind === 'asr'
    });

    if (!selectedTrack?.baseUrl) {
      return NextResponse.json({
        transcripts: [],
        fallbackData: { title: videoTitle, description: videoDesc },
        message: '자막 URL을 찾을 수 없습니다.',
        method: captionMethod
      });
    }

    // Step 6: Fetch caption XML with enhanced error handling
    let captionXml = '';
    let fetchAttempts = 0;
    const maxAttempts = 3;

    while (fetchAttempts < maxAttempts && captionXml.length === 0) {
      fetchAttempts++;
      console.log(`[Enhanced YouTube API] 자막 XML 다운로드 시도 ${fetchAttempts}/${maxAttempts}`);
      
      try {
        const captionResponse = await fetch(selectedTrack.baseUrl, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'application/xml, text/xml, */*',
            'Accept-Language': 'ko-KR,ko;q=0.9,en;q=0.8',
            'Referer': `https://www.youtube.com/watch?v=${videoId}`,
            'Origin': 'https://www.youtube.com'
          }
        });

        console.log(`[Enhanced YouTube API] 자막 응답 상태: ${captionResponse.status}`);
        
        if (captionResponse.ok) {
          captionXml = await captionResponse.text();
          console.log(`[Enhanced YouTube API] XML 길이: ${captionXml.length}`);
        } else {
          console.warn(`[Enhanced YouTube API] 자막 fetch 실패: ${captionResponse.status}`);
          
          // If this fails, wait a bit and try again
          if (fetchAttempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
      } catch (error) {
        console.error(`[Enhanced YouTube API] 자막 fetch 오류 (시도 ${fetchAttempts}):`, error);
        
        if (fetchAttempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }

    // Step 7: Parse the XML with multiple parsing strategies
    if (captionXml.length === 0) {
      console.error('[Enhanced YouTube API] 모든 시도 후에도 자막 XML을 가져올 수 없음');
      return NextResponse.json({
        transcripts: [],
        fallbackData: { title: videoTitle, description: videoDesc },
        message: '자막 다운로드에 실패했습니다. 메타데이터를 기반으로 노트를 생성합니다.',
        method: captionMethod,
        attempts: fetchAttempts
      });
    }

    console.log('[Enhanced YouTube API] XML 파싱 시작...');
    console.log('[Enhanced YouTube API] XML 첫 200자:', captionXml.substring(0, 200));

    const segments: any[] = [];
    
    // Enhanced XML parsing with multiple patterns
    const patterns = [
      // Standard format: <text start="1.23" dur="4.56">Hello world</text>
      /<text start="([^"]*)" dur="([^"]*)"[^>]*>([^<]*)<\/text>/g,
      
      // With CDATA: <text start="1.23" dur="4.56"><![CDATA[Hello world]]></text>
      /<text start="([^"]*)" dur="([^"]*)"[^>]*><!\[CDATA\[(.*?)\]\]><\/text>/g,
      
      // Alternative format: <text start="1.23" dur="4.56" text="Hello world"/>
      /<text start="([^"]*)" dur="([^"]*)"[^>]*text="([^"]*)"[^>]*\/>/g,
      
      // Any content between text tags (fallback)
      /<text[^>]*start="([^"]*)"[^>]*dur="([^"]*)"[^>]*>([\s\S]*?)<\/text>/g
    ];

    let totalMatches = 0;
    for (let i = 0; i < patterns.length && segments.length === 0; i++) {
      const pattern = patterns[i];
      const matches = [...captionXml.matchAll(pattern)];
      totalMatches += matches.length;
      
      console.log(`[Enhanced YouTube API] 패턴 ${i + 1}: ${matches.length}개 매치`);
      
      if (matches.length > 0) {
        for (const match of matches) {
          const start = parseFloat(match[1]);
          const duration = parseFloat(match[2]);
          let text = match[3] || '';
          
          // Comprehensive HTML entity decoding
          text = text
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'")
            .replace(/&nbsp;/g, ' ')
            .replace(/&#x([0-9a-fA-F]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)))
            .replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(parseInt(dec, 10)))
            .replace(/\\n/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
          
          if (text && !isNaN(start) && !isNaN(duration)) {
            segments.push({
              text,
              start,
              duration
            });
          }
        }
        break; // Found matches with this pattern, no need to try others
      }
    }

    console.log(`[Enhanced YouTube API] 파싱 완료: ${segments.length}개 세그먼트 추출`);
    
    if (segments.length > 0) {
      console.log('[Enhanced YouTube API] 첫 번째 세그먼트:', segments[0]);
      console.log('[Enhanced YouTube API] 마지막 세그먼트:', segments[segments.length - 1]);
      
      const totalText = segments.map(s => s.text).join(' ');
      console.log('[Enhanced YouTube API] 총 텍스트 길이:', totalText.length);
    }

    // Step 8: Return results
    return NextResponse.json({
      transcripts: segments,
      language: selectedTrack.languageCode || 'auto',
      method: captionMethod,
      fallbackData: segments.length === 0 ? { title: videoTitle, description: videoDesc } : null,
      stats: {
        captionTracksFound: captionTracks.length,
        xmlLength: captionXml.length,
        segmentsParsed: segments.length,
        totalTextLength: segments.map(s => s.text).join(' ').length,
        fetchAttempts
      }
    });

  } catch (error) {
    console.error('[Enhanced YouTube API] 전체 프로세스 오류:', error);
    return NextResponse.json({
      error: '자막 추출 중 오류가 발생했습니다.',
      details: error instanceof Error ? error.message : '알 수 없는 오류'
    }, { status: 500 });
  }
}